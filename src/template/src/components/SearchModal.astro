---
/**
 * SearchModal - ⌘K / Ctrl+K Search Modal
 * Uses Pagefind for static search (must build first to index content)
 */
---

<div id="search-modal" class="search-modal" role="dialog" aria-modal="true" aria-labelledby="search-title">
  <div class="search-backdrop"></div>
  <div class="search-container">
    <div class="search-header">
      <div class="search-input-wrapper">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-muted-foreground">
          <circle cx="11" cy="11" r="8"/>
          <path d="m21 21-4.3-4.3"/>
        </svg>
        <input 
          id="search-input" 
          type="search" 
          placeholder="Search documentation..." 
          class="search-input"
          autocomplete="off"
        />
        <kbd class="search-kbd">ESC</kbd>
      </div>
    </div>
    
    <div id="search-results" class="search-results">
      <div class="search-empty">
        <p class="text-muted-foreground text-sm">Type to search...</p>
      </div>
    </div>
    
    <div class="search-footer">
      <div class="search-hints">
        <span><kbd>↑</kbd><kbd>↓</kbd> to navigate</span>
        <span><kbd>↵</kbd> to select</span>
        <span><kbd>ESC</kbd> to close</span>
      </div>
    </div>
  </div>
</div>

<style>
  @reference "../styles/global.css";
  .search-modal {
    @apply fixed inset-0 z-[100] hidden;
  }
  
  .search-modal.open {
    @apply flex items-start justify-center pt-[15vh];
  }
  
  .search-backdrop {
    @apply absolute inset-0 bg-background/80 backdrop-blur-sm;
  }
  
  .search-container {
    @apply relative w-full max-w-xl mx-4 rounded border border-border bg-card shadow-2xl;
    @apply flex flex-col max-h-[60vh];
  }
  
  .search-header {
    @apply p-4 border-b border-border;
  }
  
  .search-input-wrapper {
    @apply flex items-center gap-3;
  }
  
  .search-input {
    @apply flex-1 bg-transparent text-foreground text-base;
    @apply focus:outline-none placeholder:text-muted-foreground;
  }
  
  .search-kbd {
    @apply px-2 py-1 text-xs font-mono rounded bg-muted text-muted-foreground border border-border;
  }
  
  .search-results {
    @apply flex-1 overflow-y-auto p-2;
  }
  
  .search-empty {
    @apply flex items-center justify-center py-8;
  }
  
  .search-result-item {
    @apply block px-4 py-3 rounded cursor-pointer;
    @apply hover:bg-accent transition-colors;
  }
  
  .search-result-item.selected {
    @apply bg-accent;
  }
  
  .search-result-title {
    @apply text-sm font-medium text-foreground;
  }
  
  .search-result-excerpt {
    @apply text-xs text-muted-foreground mt-1 line-clamp-2;
  }
  
  .search-footer {
    @apply p-3 border-t border-border;
  }
  
  .search-hints {
    @apply flex items-center gap-4 text-xs text-muted-foreground;
  }
  
  .search-hints kbd {
    @apply inline-flex px-1.5 py-0.5 text-[10px] font-mono rounded bg-muted border border-border;
  }
  
  .search-no-results {
    @apply text-center py-8 text-muted-foreground text-sm;
  }
</style>

<script>
  let pagefind: any = null;
  let selectedIndex = 0;
  let results: any[] = [];
  
  async function initSearch() {
    const modal = document.getElementById('search-modal');
    const backdrop = modal?.querySelector('.search-backdrop');
    const input = document.getElementById('search-input') as HTMLInputElement;
    const resultsContainer = document.getElementById('search-results');
    
    // Try to load Pagefind (only works after build)
    // Use runtime import trick to bypass Vite's static analysis
    try {
      const pagefindPath = '/pagefind/pagefind.js';
      // @ts-ignore - Dynamic import at runtime only
      pagefind = await import(/* @vite-ignore */ pagefindPath);
      await pagefind.init();
    } catch (e) {
      console.log('Pagefind not available (run build first to generate index)');
    }
    
    function openModal() {
      modal?.classList.add('open');
      document.body.style.overflow = 'hidden';
      input?.focus();
    }
    
    function closeModal() {
      modal?.classList.remove('open');
      document.body.style.overflow = '';
      if (input) input.value = '';
      if (resultsContainer) resultsContainer.innerHTML = '<div class="search-empty"><p class="text-muted-foreground text-sm">Type to search...</p></div>';
      results = [];
      selectedIndex = 0;
    }
    
    function renderResults(searchResults: any[]) {
      if (!resultsContainer) return;
      
      if (searchResults.length === 0) {
        resultsContainer.innerHTML = '<div class="search-no-results">No results found</div>';
        return;
      }
      
      resultsContainer.innerHTML = searchResults.map((result, i) => `
        <a href="${result.url}" class="search-result-item ${i === selectedIndex ? 'selected' : ''}" data-index="${i}">
          <div class="search-result-title">${result.meta?.title || result.url}</div>
          <div class="search-result-excerpt">${result.excerpt || ''}</div>
        </a>
      `).join('');
      
      // Add click handlers
      resultsContainer.querySelectorAll('.search-result-item').forEach((item) => {
        item.addEventListener('click', () => closeModal());
      });
    }
    
    function updateSelection() {
      const items = resultsContainer?.querySelectorAll('.search-result-item');
      items?.forEach((item, i) => {
        item.classList.toggle('selected', i === selectedIndex);
      });
    }
    
    // Keyboard shortcut: ⌘K or Ctrl+K
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        openModal();
      }
      
      if (e.key === 'Escape' && modal?.classList.contains('open')) {
        closeModal();
      }
      
      // Arrow navigation
      if (modal?.classList.contains('open')) {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          selectedIndex = Math.min(selectedIndex + 1, results.length - 1);
          updateSelection();
        }
        if (e.key === 'ArrowUp') {
          e.preventDefault();
          selectedIndex = Math.max(selectedIndex - 1, 0);
          updateSelection();
        }
        if (e.key === 'Enter' && results[selectedIndex]) {
          window.location.href = results[selectedIndex].url;
        }
      }
    });
    
    // Click backdrop to close
    backdrop?.addEventListener('click', closeModal);
    
    // Search as you type
    input?.addEventListener('input', async (e) => {
      const query = (e.target as HTMLInputElement).value;
      
      if (!query.trim()) {
        if (resultsContainer) resultsContainer.innerHTML = '<div class="search-empty"><p class="text-muted-foreground text-sm">Type to search...</p></div>';
        results = [];
        return;
      }
      
      if (pagefind) {
        const search = await pagefind.search(query);
        results = await Promise.all(search.results.slice(0, 8).map((r: any) => r.data()));
        selectedIndex = 0;
        renderResults(results);
      } else {
        // Fallback: no search available
        if (resultsContainer) resultsContainer.innerHTML = '<div class="search-no-results">Search requires a production build.<br/><code class="text-xs">npm run build</code></div>';
      }
    });
    
    // Expose open function for search trigger button
    (window as any).openSearchModal = openModal;
  }
  
  initSearch();
  document.addEventListener('astro:page-load', initSearch);
</script>
